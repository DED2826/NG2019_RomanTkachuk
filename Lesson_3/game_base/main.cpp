#include <iostream>
#include <random>
#include <time.h>

using namespace std;

int main()
{
    // This command used to make our randomizer work
    //

    srand(time(0));

    // Theese values is player current position
    //

    int pposx = 10; // x position
    int pposy = 10; // y position
    char mas[30][30];   // Map generated by game
    char pmap[30][30];  // Map discovered by player
    int sz = 30;        // Map size

    // Our maps are just double-dimensional arrays. So
    // to fill them we must use double cycle.
    //

    for (int i=0; i<sz; i++)
    {
        for (int j=0; j<sz; j++)
        {
            // Player map should be filled with stars,
            // actual "fog"
            //

            pmap[i][j] = '*';

            // By default, generated map should contain
            // spaces - place, where player can step
            //

            mas[i][j] = ' ';

            // If we are working with map borders - we
            // should fill it with trees

            if (j == sz-1 ||
                    j == 0 ||
                    i == sz-1 ||
                    i == 0)
                mas[i][j] = 't';
            else
            {
                // Otherwise, if this is not one of border
                // blocks - fill it with stone nor tree.
                // To create some kind of "chance", or
                // random nuber - we should use rand()
                // command. To create range of actual value
                // dont forget set % with range number. In
                // this case - I mean that tree can be created
                // with 1/40 chance (1 of 40 that tree or stone
                // will appear)
                //
                int chance = rand()%40;
                if (chance == 0)
                    mas[i][j] = 's';
                if (chance == 1)
                    mas[i][j] = 't';
            }
        }
    }


    // Spawn our player. Is it cute enough?
    //

    pmap[pposy][pposx] = '@';

    // Infinity loop. We should keep process player
    // commands, until he will decide to stop the game
    //

    while (1)
    {
        // Clear your screen. This is linux version
        // command. If you still using junk OS - use cls
        // instread
        //

        system("clear");

        // So, before process any command - we should
        // draw 'interface'. In this sample, the 'interface'
        // actually is full player-discovered map with
        // command prompt. Feel free to edit this, and try
        // add after map drawing some of your interface
        // stuff
        //

        for (int i=0; i<sz; i++)
        {
            for (int j=0; j<sz; j++)
            {
                cout << pmap[i][j];
            }
            cout << endl;
        }

        // This is player commands. For now I decided to
        // use here int variable, and think that 8 will mean
        // 'move forward', 2 - 'backward', 4 - 'left',
        // 6 - 'right', and 0 - 'exit game'. Better use here
        // char variable, so feel free to impement :)
        //

        int action = -1;
        cout << endl << endl << ">";
        cin >> action;

        // The new position of our player. Before move him,
        // we should create 'phantom' of his new position,
        // and check: can our player step there, or not?
        //

        int newposx = pposx;
        int newposy = pposy;

        // Here we creating our new position. Each our
        // command, as described above will process
        // new position variables (except 0)
        //

        switch (action) {
        case 8: newposy--; break;
        case 2: newposy++; break;
        case 4: newposx--; break;
        case 6: newposx++; break;
        case 0: cout << "bye!"; return 0;
        }

        // First of all, check: if this position is
        // legit. We are doesn't want mash our RAM by
        // exiting from array range, don't you think?
        //

        if (newposx >= sz ||
                newposx < 0 ||
                newposy >= sz ||
                newposy < 0)
            cout << "WRONG MOVE" << endl;
        else
        {
            // After that, if all ok - check, that our place
            // is not owned by tree or stone
            //
            if (mas[newposy][newposx] == 't' ||
                    mas[newposy][newposx] == 's')
                cout << "Oh god! I can't step here" << endl;
            else
            {
                // At least, we can step here! So clear up old
                // position with same place from "generated map"
                //
                pmap[pposy][pposx] = mas[pposy][pposx];

                // Spawn player at new position
                //
                pmap[newposy][newposx] = '@';

                // Discover territory around our player (3x3)
                // block
                //
                pmap[newposy][newposx+1] = mas[newposy][newposx+1];
                pmap[newposy][newposx-1] = mas[newposy][newposx-1];
                pmap[newposy-1][newposx] = mas[newposy-1][newposx];
                pmap[newposy+1][newposx] = mas[newposy+1][newposx];

                pmap[newposy-1][newposx+1] = mas[newposy-1][newposx+1];
                pmap[newposy+1][newposx+1] = mas[newposy+1][newposx+1];
                pmap[newposy-1][newposx-1] = mas[newposy-1][newposx-1];
                pmap[newposy+1][newposx-1] = mas[newposy+1][newposx-1];

                // And remember our new position!
                //
                pposx = newposx;
                pposy = newposy;
            }
        }
    }
}
