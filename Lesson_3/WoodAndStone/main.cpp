#include <iostream>
#include <random>
#include <time.h>

using namespace std;

int main()
{
    // This command used to make our randomizer work
    //

    srand(time(0));

    // Theese values is player current position
    //

    int pposx = 10; // x position
    int pposy = 10; // y position
    char mas[30][30];   // Map generated by game
    char pmap[30][30];  // Map discovered by player
    int sz = 30;        // Map size

    int wood = 0; // Amount of wood
    int coal = 0; // Amount of coal
    int cobblestone = 0; // Amount of cobblestone
    int stone = 0; // Amount of stone
    int iron = 0; // Amount of iron
    int gold = 0; // Amount of gold

    // Array of elements, throu which we can't step

    char blocked[50];
    for (int i=0; i<50; i++)
    {
        blocked[i] = '?';
    }

    blocked[0] = 't';   // tree
    blocked[1] = 's';   // stone
    blocked[2] = 'T';   // Tree Wall
    blocked[3] = 'W';   // Stone Wall

    int amount_of_mines = 0; // "mine" will give you every move around one cobblestone with chance 25% and iron with chance 10% and gold 1%

    // Our maps are just double-dimensional arrays. So
    // to fill them we must use double cycle.
    //

    for (int i=0; i<sz; i++)
    {
        for (int j=0; j<sz; j++)
        {
            // Player map should be filled with stars,
            // actual "fog"
            //

            pmap[i][j] = '*';

            // By default, generated map should contain
            // spaces - place, where player can step
            //

            mas[i][j] = ' ';

            // If we are working with map borders - we
            // should fill it with trees

            if (j == sz-1 ||
                    j == 0 ||
                    i == sz-1 ||
                    i == 0)
                mas[i][j] = '?';
            else
            {
                // Otherwise, if this is not one of border
                // blocks - fill it with stone nor tree.
                // To create some kind of "chance", or
                // random nuber - we should use rand()
                // command. To create range of actual value
                // dont forget set % with range number. In
                // this case - I mean that tree can be created
                // with 1/40 chance (1 of 40 that tree or stone
                // will appear)
                //
                int chance = rand()%40;
                if (chance == 0)
                    mas[i][j] = 's';
                if (chance == 1)
                    mas[i][j] = 't';
            }
        }
    }


    // Spawn our player. Is it cute enough?
    //

    pmap[pposy][pposx] = '@';

    // If game will send us some kind of error message - we shouldn't clear
    // our screen
    //

    int error_occured = 0;

    // Infinity loop. We should keep process player
    // commands, until he will decide to stop the game
    //

    while (1)
    {
        // Clear your screen. This is linux version
        // command. If you still using junk OS - use cls
        // instread
        //

        if (error_occured == 0)
        {
            system("clear");
            cout << endl;
        }
        error_occured = 0;

        // So, before process any command - we should
        // draw 'interface'. In this sample, the 'interface'
        // actually is full player-discovered map with
        // command prompt. Feel free to edit this, and try
        // add after map drawing some of your interface
        // stuff
        //

        for (int i=0; i<sz; i++)
        {
            for (int j=0; j<sz; j++)
            {
                cout << pmap[i][j];
            }
            cout << endl;
        }

        for (int i=0; i<30; i++)
            cout << "=";
        cout << endl;
        cout << "Wood: " << wood << "\t\tCoal: " << coal << endl;
        for (int i=0; i<30; i++)
            cout << "-";
        cout << endl;
        cout << "Cobble: " << cobblestone << "\tStone: " << stone << endl;
        for (int i=0; i<30; i++)
            cout << "-";
        cout << endl;
        cout << "Iron: " << iron << "\t\tGold: " << gold << endl;
        for (int i=0; i<30; i++)
            cout << "=";
        cout << endl;

        // This is player commands. For now I decided to
        // use here int variable, and think that 8 will mean
        // 'move forward', 2 - 'backward', 4 - 'left',
        // 6 - 'right', and 0 - 'exit game'. Better use here
        // char variable, so feel free to impement :)
        //

        char action = 0;
        cout << endl << endl << ">";
        cin >> action;

        // The new position of our player. Before move him,
        // we should create 'phantom' of his new position,
        // and check: can our player step there, or not?
        //

        int newposx = pposx;
        int newposy = pposy;

        // Which direction we will act
        //

        char direction = 0;

        // Shall we move?
        //

        int pmove = 0;

        // Here we creating our new position. Each our
        // command, as described above will process
        // new position variables (except 0)
        //

        switch (action) {
            // Here commands for moving :)
            case '8': newposy--; pmove = 1; break;
            case '2': newposy++; pmove = 1; break;
            case '4': newposx--; pmove = 1; break;
            case '6': newposx++; pmove = 1; break;
            // Here our actions :)
            case 'f':
                    {
                        cout << "Which direction fell tree (l,r,f,b): ";
                        cin >> direction;
                    }; break;
            case 'm':
                    {
                        cout << "Which direction mine stone (l,r,f,b): ";
                        cin >> direction;
                    }; break;
            case 'b':
                    {
                        cout << "Which direction build (l,r,f,b): ";
                        cin >> direction;
                    }; break;
            case 'q': cout << "bye!"; return 0;
        }

        // First of all, check: if this position is
        // legit. We are doesn't want mash our RAM by
        // exiting from array range, don't you think?
        //

        if (newposx >= sz ||
                newposx < 0 ||
                newposy >= sz ||
                newposy < 0)
        {
            error_occured = 1;
            system("clear");
            cout << "WRONG MOVE" << endl;
        }
        else if ( pmove == 1 ) // We really want to move
        {
            // After that, if all ok - check, that our place
            // is not owned by tree or stone
            //

            int blocked_flag = 0;

            int i=0;
            while (i<50 && mas[newposy][newposx] != blocked[i])
            {
                i++;
            }

            if (i != 50)
                blocked_flag = 1;

            if (blocked_flag == 1)
            {
                system("clear");
                cout << "Oh god! I can't step here" << endl;
                error_occured = 1;
            }
            else
            {
                // At least, we can step here! So clear up old
                // position with same place from "generated map"
                //
                pmap[pposy][pposx] = mas[pposy][pposx];

                // Spawn player at new position
                //
                pmap[newposy][newposx] = '@';

                // Discover territory around our player (3x3)
                // block
                //
                pmap[newposy][newposx+1] = mas[newposy][newposx+1];
                pmap[newposy][newposx-1] = mas[newposy][newposx-1];
                pmap[newposy-1][newposx] = mas[newposy-1][newposx];
                pmap[newposy+1][newposx] = mas[newposy+1][newposx];

                pmap[newposy-1][newposx+1] = mas[newposy-1][newposx+1];
                pmap[newposy+1][newposx+1] = mas[newposy+1][newposx+1];
                pmap[newposy-1][newposx-1] = mas[newposy-1][newposx-1];
                pmap[newposy+1][newposx-1] = mas[newposy+1][newposx-1];

                // And remember our new position!
                //
                pposx = newposx;
                pposy = newposy;
            }
        }

        // Process actions!!!!
        //

        if (action == 'f' || action == 'm' ||
                action == 'b')
            switch (direction)
            {
                case 'l': newposx--; break;
                case 'r': newposx++; break;
                case 'f': newposy--; break;
                case 'b': newposy++; break;
            }

        if (action == 'f') // If we decided to fell trees
        {
            if (mas[newposy][newposx] == 't')
            {
                mas[newposy][newposx] = ' ';
                pmap[newposy][newposx] = ' ';
                wood += rand()%15;
            }
            else
            {
                error_occured = 1;
                system("clear");
                cout << "No trees found in that direction!" << endl;
            }
        }

        if (action == 'm') // If we decided to mine
        {
            if (mas[newposy][newposx] == 's')
            {
                mas[newposy][newposx] = ' ';
                pmap[newposy][newposx] = ' ';
                cobblestone += rand()%15;;
            }
            else
            {
                error_occured = 1;
                system("clear");
                cout << "No stone found in that direction!" << endl;
            }
        }
        if (action == 'b' && mas[newposy][newposx] == ' ')
        {
            system ("clear");
            cout << "What you decided to build?" << endl;
            cout << "T - Tree wall (5 wood)" << endl;
            cout << "S - Stone wall (10 stone)" << endl;
            cout << "d - door (3 wood)" << endl;
            cout << ", - roof (1 wood)" << endl;
            cout << "m - mine (20 cobblestone, 30 trees)" << endl;
            for (int i=0; i<30; i++)
                cout << "-";
            cout << endl;
            cout << ">";
            char build = 0;
            cin >> build;

            switch(build)
            {
                case 'T':
                {
                    if (wood >= 5)
                    {
                        mas[newposy][newposx] = 'T';
                        pmap[newposy][newposx] = 'T';
                        wood -= 5;
                    }
                    else
                    {
                        error_occured = 1;
                        system("clear");
                        cout << "Not enough wood!" << endl;
                    }
                }; break;

                case 'S':
                {
                    if (stone >= 10)
                    {
                        mas[newposy][newposx] = 'S';
                        pmap[newposy][newposx] = 'S';
                        stone -= 10;
                    }
                    else
                    {
                        error_occured = 1;
                        system("clear");
                        cout << "Not enough stone!" << endl;
                    }
                }; break;

                case 'd':
                {
                    if (wood >= 3)
                    {
                        mas[newposy][newposx] = 'd';
                        pmap[newposy][newposx] = 'd';
                        wood -= 3;
                    }
                    else
                    {
                        error_occured = 1;
                        system("clear");
                        cout << "Not enough wood!" << endl;
                    }
                }; break;

                case ',':
                {
                    if (wood >= 1)
                    {
                        mas[newposy][newposx] = ',';
                        pmap[newposy][newposx] = ',';
                        wood -= 1;
                    }
                    else
                    {
                        error_occured = 1;
                        system("clear");
                        cout << "Not enough wood!" << endl;
                    }
                }; break;
                case 'm':
                {
                    if (wood >= 30 && cobblestone >= 20)
                    {
                        mas[newposy][newposx] = 'm';
                        pmap[newposy][newposx] = 'm';
                        wood -= 30;
                        cobblestone -= 20;
                        amount_of_mines++;
                    }
                    else
                    {
                        error_occured = 1;
                        system("clear");
                        cout << "Not enough wood and cobblestone!" << endl;
                    }
                }
            }
        }

        // Now working with mines!

        // For each mine we have chance to mine some resources
        for (int i=0; i<amount_of_mines; i++)
        {
            // Chance to mine cobblestone
            //
            int chance = rand()%4;
            if (chance == 0)
                cobblestone += rand()%5+1;

            // Chance to mine coal
            //
            chance = rand()%6;
            if (chance == 0)
                coal += 1;

            // Chance to mine iron
            //
            chance = rand()%16;
            if (chance == 0)
                iron += 1;

            // Chance to mine gold
            //
            chance = rand()%50;
            if (chance == 0)
                gold += 1;
        }
    }
}
